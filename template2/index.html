<!DOCTYPE html>
<html>
<head>
    <title>Webcam YOLO OBB</title>
    <style>
        #container {
            position: relative;
            width: 640px;
            height: 480px;
        }
        #video {
            width: 640px;
            height: 480px;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <h1>Webcam YOLO OBB 실시간 스트림</h1>
    <div id="container">
        <!-- 영상은 img src="/video_feed"로 받음 -->
        <img id="video" src="/video_feed" alt="Webcam Stream" />
        <canvas id="overlay" width="640" height="480"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');

        // WebSocket 연결: 현재 호스트에 /ws 엔드포인트로 연결
        const ws = new WebSocket(`ws://${location.host}/ws`);

        // 이전 프레임 좌표 저장용 (좌표 변동 없으면 다시 그리지 않기 위함)
        let prevBoxes = [];

        ws.onopen = () => {
            // 30fps 폴링용 타이머 (33ms마다 서버에 좌표 요청)
            setInterval(() => {
                if(ws.readyState === WebSocket.OPEN) {
                    ws.send("get");  // 아무 메시지나 보내서 서버에 최신 좌표 요청
                }
            }, 33);
        };

        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);

            // 좌표가 변했는지 확인하는 함수
            function isSameBoxes(boxes1, boxes2, tolerance = 100000) {
                if(boxes1.length !== boxes2.length) return false;
                for(let i=0; i<boxes1.length; i++) {
                    const b1 = boxes1[i];
                    const b2 = boxes2[i];
                    if(b1.class_id !== b2.class_id) return false;
                    for(let j=0; j<b1.points.length; j++) {
                        const dx = Math.abs(b1.points[j][0] - b2.points[j][0]);
                        const dy = Math.abs(b1.points[j][1] - b2.points[j][1]);
                        if(dx > tolerance || dy > tolerance) return false;
                    }
                }
                return true;
            }

            // 좌표 변동 없으면 다시 그리지 않고 return
            if(isSameBoxes(prevBoxes, data)) {
                return;
            }
            prevBoxes = data;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            data.forEach(box => {
                const points = box.points;
                const cls = box.class_id;
                const clsName = box.class_name;

                ctx.beginPath();
                ctx.moveTo(points[0][0], points[0][1]);
                for(let i=1; i<points.length; i++){
                    ctx.lineTo(points[i][0], points[i][1]);
                }
                ctx.closePath();

                // 라벨별 색상
                if(cls === 0) ctx.strokeStyle = 'blue';
                else if(cls === 1) ctx.strokeStyle = 'black';
                else if(cls === 2) ctx.strokeStyle = 'green';
                else ctx.strokeStyle = 'red';

                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = ctx.strokeStyle;
                ctx.font = "16px Arial";
                ctx.fillText(clsName, points[0][0], points[0][1] - 5);
            });
        };

        ws.onerror = (e) => {
            console.error("WebSocket error:", e);
        };
    </script>
</body>
</html>


 <!-- uvicorn main:app --reload -->